### 概述
    动态规划算法其实是一种解决最优问题的方法统称。其中包括了各种各样的问题，这些问题的具体解决方案各有不同。这些问题的难点一般都在于，如何将具体问题建模成动态规划模型。
使用动态规划需要有三个条件：
- 旧的状态不发生改变（无后效性）
- 问题的最优解包含的子问题也是最优的，则该问题具有最优子结构（最优子结构）
- 最优子结构可以存储

满足这三个前提条件之后，则可以将问题用动态规划求解。
动态规划求解过程的关键则是状态转移方程。
    
#
### 思想
动态规划的解法分为自顶向下（表格记忆）以及自底向上法，这两种方法其实代表了同一种思路，前者由于计算机语言的递归功能，更便于让人理解，后者则是直接体现动态规划思想的方法，省时省力（时间、空间复杂度）的解法。
这两种方法的思路都是：层层递进，从小积累大再到最终结果。
```java
//TODO 完成思想概述
```
以下三个动态规划问题的求解，体现了状态转移方程在求解动态规划问题时扮演的关键角色。
#
### 解题
- [x] 走台阶
>第一道模拟题为走台阶问题:

描述：*有n个阶梯，一个人每一步只能跨一个台阶或是两个台阶，问这个人一共有多少种走法？*

首先要对这个问题进行抽象，n个阶梯，每个阶梯都代表一个”位置“， 就像是图论中的一个”点“，然后这些n个不同位置之间会有一些桥梁把它们连起来，思路如下图：
![走台阶示意](https://github.com/macttt/OJCode/raw/master/src/main/resources/image/image-20190508111933.jpeg "123")
相应的**状态转移方程**：
```java
dp[n] = dp[n-1]+dp[n-2];
```
这里要注意理解走台阶深层的状态转移意义，并举一反三到其他的问题上面。
1.例如
```java
dp[4] = dp[3]+dp[2];
```
上方的转移方程中，描述了想要走到第4个台阶，可以由两种方法到达：
>- 第3个台阶再走1步
>- 第2个台阶再走2步

到达第4层台阶。

>之前总有一个疑惑，第3台阶和第2台阶其中必然会有重复的走法，为何可以简单地直接相加？
    
&nbsp;&nbsp;&nbsp;&nbsp;这里可以理解为:虽然 **dp[3]** 中必然包含了 **dp[2]** 中的走法，但是，由于 **dp[3]+1** 的走法必然与 **dp[2]+2** 的走法不同（最后一步的走法不同），所以可以直接相加。从而得到状态转移方程：
> **dp[n] = dp[n-1]+dp[n-2]** 

并且，最后一次走1步或者2步，并不会影响到之前走的方法，所以可以保证动态规划的**无后效性**。
同理，如果题目改为一次可以最多走三步，那么该状态转移方程为：
>**dp[n]= dp[n-3]+dp[n-2]+dp[n-1]**

```
//TODO 剩下三道题
```
